import os
import sys
import json
import base64
import time
import re
import requests
import google.generativeai as genai
from pathlib import Path
import zipfile
import io
import traceback

# ==============================================================================
# I. C·∫§U H√åNH V√Ä THI·∫æT L·∫¨P TO√ÄN C·ª§C
# ==============================================================================
print("--- ‚öôÔ∏è  ƒêang kh·ªüi t·∫°o T√°c nh√¢n AI T·ª± tr·ªã ---")
try:
    GH_USER = os.environ["GH_USER"]
    GITHUB_TOKEN = os.environ["GITHUB_TOKEN"]
    GEMINI_API_KEY = os.environ["GEMINI_API_KEY"]
    RELEASE_KEYSTORE_PASSWORD = os.environ["RELEASE_KEYSTORE_PASSWORD"]
    RELEASE_KEY_ALIAS = os.environ["RELEASE_KEY_ALIAS"]
    RELEASE_KEY_PASSWORD = os.environ["RELEASE_KEY_PASSWORD"]
except KeyError as e:
    print(f"‚ùå L·ªñI: Thi·∫øu bi·∫øn m√¥i tr∆∞·ªùng b·∫Øt bu·ªôc: {e}")
    sys.exit(1)

COMMIT_AUTHOR = {"name": "Autonomous AI Agent", "email": "agent@example.com"}
API_BASE_URL = "https://api.github.com"
HEADERS = {"Authorization": f"Bearer {GITHUB_TOKEN}", "Accept": "application/vnd.github.v3+json"}
genai.configure(api_key=GEMINI_API_KEY)
MAX_DEBUG_LOOPS = 3

GITIGNORE_CONTENT = "# Flutter\n.flutter-plugins\n.flutter-plugins-dependencies\n.packages\n.pub-cache/\n.pub/\n/build/\n/ios/\n/windows/\n/linux/\n/macos/\n*.iml\n*.ipr\n*.iws\n*.swp\n*.lock\n*.snapshot\n.idea/\n"
SELF_HEALING_WORKFLOW = r"""
name: Build and Release Flutter APK
on: [push, workflow_dispatch]
jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-java@v4
        with: { java-version: '17', distribution: 'temurin' }
      - uses: subosito/flutter-action@v2
        with: { channel: 'stable' }
      - run: flutter pub get
      - name: Decode Keystore and Create Properties
        run: |
          mkdir -p android/app
          echo "${{ secrets.RELEASE_KEYSTORE_BASE64 }}" | base64 --decode > android/app/upload-keystore.jks
          echo "storePassword=${{ secrets.RELEASE_KEYSTORE_PASSWORD }}" > android/key.properties
          echo "keyPassword=${{ secrets.RELEASE_KEY_PASSWORD }}" >> android/key.properties
          echo "keyAlias=${{ secrets.RELEASE_KEY_ALIAS }}" >> android/key.properties
          echo "storeFile=../app/upload-keystore.jks" >> android/key.properties
      - name: Build APK
        run: flutter build apk --release
      - uses: actions/upload-artifact@v4
        with: { name: release-apk, path: build/app/outputs/flutter-apk/app-release.apk }
"""

# ==============================================================================
# II. B·ªò C√îNG C·ª§ (TOOLKIT) C·ª¶A AGENT
# ==============================================================================

def call_gemini(prompt, use_pro_model=False):
    model_name = "gemini-2.5-pro-latest" if use_pro_model else "gemini-2.5-flash-latest"
    print(f"--- üß† G·ªçi AI ({model_name})... ---")
    model = genai.GenerativeModel(model_name)
    safety_settings = [{"category": c, "threshold": "BLOCK_NONE"} for c in ["HARM_CATEGORY_HARASSMENT", "HARM_CATEGORY_HATE_SPEECH", "HARM_CATEGORY_SEXUALLY_EXPLICIT", "HARM_CATEGORY_DANGEROUS_CONTENT"]]
    
    # === C·∫¢I TI·∫æN: X·ª¨ L√ù L·ªñI QUOTA TH√îNG MINH ===
    for attempt in range(1, 4):
        try:
            response = model.generate_content(prompt, request_options={'timeout': 400}, safety_settings=safety_settings)
            if hasattr(response, 'text'):
                return response.text
            elif not response.parts:
                raise ValueError(f"Ph·∫£n h·ªìi t·ª´ AI b·ªã tr·ªëng ho·∫∑c b·ªã ch·∫∑n. L√Ω do: {getattr(response.prompt_feedback, 'block_reason', 'Kh√¥ng r√µ')}")
            else:
                return "".join(part.text for part in response.parts if hasattr(part, 'text'))
        except Exception as e:
            # Ch·ªâ th·ª≠ l·∫°i n·∫øu l√† l·ªói ResourceExhausted (429)
            if "429" in str(e) and "ResourceExhausted" in str(type(e).__name__):
                if attempt < 3:
                    wait_time = 65  # ƒê·ª£i h∆°n 1 ph√∫t ƒë·ªÉ reset quota RPM (Requests Per Minute)
                    print(f"   - ‚ö†Ô∏è  L·ªói Quota (429). ƒê√¢y l√† gi·ªõi h·∫°n c·ªßa g√≥i mi·ªÖn ph√≠. ƒêang ƒë·ª£i {wait_time} gi√¢y...")
                    time.sleep(wait_time)
                    continue # Th·ª≠ l·∫°i v√≤ng l·∫∑p
                else:
                    print("   - ‚ùå ƒê√£ th·ª≠ 3 l·∫ßn v√† v·∫´n b·ªã l·ªói Quota. N√¢ng c·∫•p l√™n g√≥i tr·∫£ ph√≠ c·ªßa Google AI Platform c√≥ th·ªÉ gi·∫£i quy·∫øt v·∫•n ƒë·ªÅ n√†y.")
                    raise e
            else:
                # N√©m ra c√°c l·ªói kh√°c ngay l·∫≠p t·ª©c
                print(f"   - L·ªói khi g·ªçi Gemini API: {e}")
                raise

def extract_json_from_ai(text):
    print("   - ƒêang tr√≠ch xu·∫•t JSON t·ª´ ph·∫£n h·ªìi c·ªßa AI...")
    if not text or not text.strip():
        raise ValueError("Ph·∫£n h·ªìi t·ª´ AI l√† chu·ªói r·ªóng.")
        
    match = re.search(r'```json\s*(\{.*?\})\s*```', text, re.DOTALL)
    if not match:
        match = re.search(r'(\{.*?\})', text, re.DOTALL) # Fallback n·∫øu kh√¥ng c√≥ markdown
    if not match:
        raise ValueError(f"Kh√¥ng t√¨m th·∫•y JSON h·ª£p l·ªá trong ph·∫£n h·ªìi:\n{text}")
        
    return json.loads(match.group(1), strict=False)

def github_api_request(method, url, json_data=None):
    response = requests.request(method, url, headers=HEADERS, json=json_data, timeout=60)
    response.raise_for_status()
    return response.json() if response.status_code != 204 and response.content else None

# ==============================================================================
# III. C√ÅC H√ÄNH ƒê·ªòNG C·∫§P CAO (ACTIONS) C·ª¶A AGENT
# ==============================================================================

class AgentActions:
    def __init__(self, repo_owner, repo_name):
        self.repo_owner = repo_owner
        self.repo_name = repo_name
        self.repo_full_name = f"{repo_owner}/{repo_name}"

    def generate_initial_code(self, user_prompt, language):
        prompt = f'B·∫°n l√† m·ªôt k·ªπ s∆∞ ph·∫ßn m·ªÅm chuy√™n v·ªÅ {language}. D·ª±a tr√™n y√™u c·∫ßu: "{user_prompt}", h√£y t·∫°o c·∫•u tr√∫c file v√† th∆∞ m·ª•c ho√†n ch·ªânh. Tr·∫£ v·ªÅ d∆∞·ªõi d·∫°ng m·ªôt ƒë·ªëi t∆∞·ª£ng JSON l·ªìng nhau duy nh·∫•t, bao b·ªçc trong kh·ªëi ```json ... ```.'
        
        for attempt in range(1, 4):
            print(f"--- üß† G·ªçi AI ƒë·ªÉ t·∫°o code (L·∫ßn th·ª≠ {attempt}/3)... ---")
            try:
                response_text = call_gemini(prompt)
                file_tree = extract_json_from_ai(response_text)
                print("   - ‚úÖ AI ƒë√£ t·∫°o code v√† JSON h·ª£p l·ªá.")
                return file_tree
            except Exception as e:
                print(f"   - ‚ö†Ô∏è L·ªói ·ªü l·∫ßn th·ª≠ {attempt}: {e}")
                if attempt < 3:
                    print("   - ƒêang ƒë·ª£i 5 gi√¢y tr∆∞·ªõc khi th·ª≠ l·∫°i...")
                    time.sleep(5)
                else:
                    print("   - ‚ùå ƒê√£ th·ª≠ 3 l·∫ßn v√† v·∫´n th·∫•t b·∫°i. N√©m ra l·ªói cu·ªëi c√πng.")
                    raise e
        raise RuntimeError("Kh√¥ng th·ªÉ t·∫°o code t·ª´ AI sau nhi·ªÅu l·∫ßn th·ª≠.")

    def create_github_repo(self):
        print(f"--- üõ∞Ô∏è  ƒêang t·∫°o repository: {self.repo_name} ---")
        github_api_request("POST", f"{API_BASE_URL}/user/repos", {"name": self.repo_name, "private": False, "auto_init": True})
        print("   - ‚úÖ Repo ƒë√£ ƒë∆∞·ª£c t·∫°o. ƒê·ª£i GitHub x·ª≠ l√Ω...")
        
        ref_url = f"{API_BASE_URL}/repos/{self.repo_full_name}/git/refs/heads/main"
        for i in range(10):
            time.sleep(3)
            try:
                main_ref = github_api_request("GET", ref_url)
                if main_ref:
                    print("   - ‚úÖ Repo ƒë√£ s·∫µn s√†ng.")
                    return main_ref
            except requests.exceptions.HTTPError as e:
                if e.response.status_code == 404: continue
                else: raise e
        raise ConnectionError("Repo kh√¥ng s·∫µn s√†ng sau 30 gi√¢y.")

    def commit_files(self, file_tree, message, main_ref):
        print(f"--- ‚¨ÜÔ∏è  ƒêang commit {len(file_tree)} file l√™n repo ---")
        flat_tree = self._flatten_file_tree(file_tree)
        latest_commit_sha = main_ref['object']['sha']
        base_tree_sha = github_api_request("GET", main_ref['object']['url'])['tree']['sha']
        
        tree_elements = []
        for path, content in flat_tree.items():
            if not isinstance(content, str): continue
            blob_sha = github_api_request("POST", f"{API_BASE_URL}/repos/{self.repo_full_name}/git/blobs", {"content": content, "encoding": "utf-8"})['sha']
            tree_elements.append({"path": path, "mode": "100644", "type": "blob", "sha": blob_sha})
        
        new_tree_sha = github_api_request("POST", f"{API_BASE_URL}/repos/{self.repo_full_name}/git/trees", {"base_tree": base_tree_sha, "tree": tree_elements})['sha']
        new_commit_sha = github_api_request("POST", f"{API_BASE_URL}/repos/{self.repo_full_name}/git/commits", {"message": message, "author": COMMIT_AUTHOR, "parents": [latest_commit_sha], "tree": new_tree_sha})['sha']
        
        update_ref_url = f"{API_BASE_URL}/repos/{self.repo_full_name}/git/refs/heads/main"
        github_api_request("PATCH", update_ref_url, {"sha": new_commit_sha})
        print("   - ‚úÖ ƒê√£ commit th√†nh c√¥ng!")
    
    def upload_secrets(self):
        print(f"--- üîë ƒêang t·ª± ƒë·ªông th√™m secrets v√†o repo {self.repo_name} ---")
        try:
            from nacl import encoding, public
        except ImportError:
            print("‚ùå L·ªñI: Th∆∞ vi·ªán 'pynacl' ch∆∞a ƒë∆∞·ª£c c√†i ƒë·∫∑t. H√£y ch·∫°y: pip install pynacl")
            sys.exit(1)
        
        try:
            keystore_b64 = Path("keystore_base64.txt").read_text().strip()
        except FileNotFoundError:
            print("‚ùå L·ªñI: Kh√¥ng t√¨m th·∫•y file 'keystore_base64.txt'.")
            sys.exit(1)
            
        secrets_to_upload = {"RELEASE_KEYSTORE_BASE64": keystore_b64, "RELEASE_KEYSTORE_PASSWORD": RELEASE_KEYSTORE_PASSWORD, "RELEASE_KEY_ALIAS": RELEASE_KEY_ALIAS, "RELEASE_KEY_PASSWORD": RELEASE_KEY_PASSWORD}
        
        key_url = f"{API_BASE_URL}/repos/{self.repo_full_name}/actions/secrets/public-key"
        key_data = github_api_request("GET", key_url)
        public_key = public.PublicKey(key_data['key'], encoding.Base64Encoder())
        sealed_box = public.SealedBox(public_key)

        for name, value in secrets_to_upload.items():
            encrypted = base64.b64encode(sealed_box.encrypt(value.encode("utf-8"))).decode("utf-8")
            github_api_request("PUT", f"{API_BASE_URL}/repos/{self.repo_full_name}/actions/secrets/{name}", {"encrypted_value": encrypted, "key_id": key_data['key_id']})
        
        print(f"   - ‚úÖ ƒê√£ th√™m th√†nh c√¥ng {len(secrets_to_upload)} secrets.")

    def get_latest_workflow_run(self):
        print(f"--- ‚è±Ô∏è  ƒêang ki·ªÉm tra tr·∫°ng th√°i build cho {self.repo_full_name} ---")
        runs = github_api_request("GET", f"{API_BASE_URL}/repos/{self.repo_full_name}/actions/runs")
        if not runs or not runs.get('workflow_runs'):
            return None
        return runs['workflow_runs'][0]

    def get_failed_job_log(self, run_id):
        print(f"--- üì• ƒêang t·∫£i log l·ªói t·ª´ Run ID: {run_id} ---")
        response = requests.get(f"{API_BASE_URL}/repos/{self.repo_full_name}/actions/runs/{run_id}/logs", headers=HEADERS, stream=True, timeout=60)
        response.raise_for_status()
        with zipfile.ZipFile(io.BytesIO(response.content)) as z:
            log_file_name = next((name for name in z.namelist() if 'build' in name and name.endswith('.txt')), z.namelist()[0])
            with z.open(log_file_name) as f:
                log_content = f.read().decode('utf-8', errors='ignore')
        return "\n".join(log_content.splitlines()[-200:])

    def get_file_content(self, file_path):
        try:
            response = github_api_request("GET", f"{API_BASE_URL}/repos/{self.repo_full_name}/contents/{file_path}")
            return base64.b64decode(response['content']).decode('utf-8'), response['sha']
        except Exception: return None, None
    
    def apply_code_patch(self, file_path, new_content, commit_message, sha):
        print(f"--- ü©π ƒêang √°p d·ª•ng b·∫£n v√° cho file: {file_path} ---")
        github_api_request("PUT", f"{API_BASE_URL}/repos/{self.repo_full_name}/contents/{file_path}", {"message": commit_message, "content": base64.b64encode(new_content.encode('utf-8')).decode('utf-8'), "sha": sha, "author": COMMIT_AUTHOR})
        print("   - ‚úÖ ƒê√£ commit b·∫£n v√° th√†nh c√¥ng!")
        
    def _flatten_file_tree(self, file_tree, path=''):
        items = {}
        for key, value in file_tree.items():
            new_path = os.path.join(path, key) if path else key
            if isinstance(value, dict): items.update(self._flatten_file_tree(value, new_path))
            else: items[new_path] = value
        return items

# ==============================================================================
# IV. "B·ªò N√ÉO" ƒêI·ªÄU KHI·ªÇN C·ª¶A AGENT
# ==============================================================================

class AutonomousAgent:
    def __init__(self, user_prompt, repo_name, language="Flutter"):
        self.state = "STARTING"
        self.user_prompt = user_prompt
        self.repo_name = repo_name
        self.language = language
        self.debug_attempts = 0
        self.actions = AgentActions(GH_USER, repo_name)
    
    def run(self):
        try:
            # GIAI ƒêO·∫†N 1
            self.state = "GENERATING"
            print(f"\n=== GIAI ƒêO·∫†N 1: KH·ªûI T·∫†O D·ª∞ √ÅN ({self.repo_name}) ===")
            file_tree = self.actions.generate_initial_code(self.user_prompt, self.language)
            file_tree['.gitignore'] = GITIGNORE_CONTENT
            if self.language.lower() == 'flutter':
                file_tree[".github/workflows/build.yml"] = SELF_HEALING_WORKFLOW
            
            main_ref = self.actions.create_github_repo()
            self.actions.commit_files(file_tree, "feat: Initial commit by Autonomous Agent", main_ref)
            if self.language.lower() == 'flutter':
                self.actions.upload_secrets()

            # GIAI ƒêO·∫†N 2
            self.state = "MONITORING"
            print(f"\n=== GIAI ƒêO·∫†N 2: GI√ÅM S√ÅT BUILD (T·ªëi ƒëa {MAX_DEBUG_LOOPS} l·∫ßn s·ª≠a l·ªói) ===")
            while self.debug_attempts < MAX_DEBUG_LOOPS:
                print(f"\n--- V√≤ng l·∫∑p gi√°m s√°t (L·∫ßn {self.debug_attempts + 1}/{MAX_DEBUG_LOOPS}) ---")
                
                # C·∫¢I TI·∫æN: ƒê·ª£i workflow kh·ªüi ƒë·ªông
                print("   - ƒêang ƒë·ª£i workflow kh·ªüi ƒë·ªông (t·ªëi ƒëa 2 ph√∫t)...")
                initial_run = None
                for _ in range(4): # Th·ª≠ 4 l·∫ßn, m·ªói l·∫ßn c√°ch nhau 30s
                    initial_run = self.actions.get_latest_workflow_run()
                    if initial_run: break
                    time.sleep(30)
                
                if not initial_run:
                    print("   - ‚ö†Ô∏è  Kh√¥ng ph√°t hi·ªán workflow n√†o ƒë∆∞·ª£c kh·ªüi ƒë·ªông. D·ª´ng l·∫°i.")
                    break
                
                print(f"   - ƒê√£ ph√°t hi·ªán workflow (ID: {initial_run['id']}). ƒêang ƒë·ª£i ho√†n th√†nh...")
                latest_run = None
                for _ in range(10): # Ch·ªù t·ªëi ƒëa 10 * 30s = 5 ph√∫t
                    latest_run = self.actions.get_latest_workflow_run()
                    if latest_run and latest_run['id'] == initial_run['id'] and latest_run['status'] == "completed": 
                        break
                    print(f"   - Tr·∫°ng th√°i hi·ªán t·∫°i: {latest_run.get('status', 'unknown')}. ƒê·ª£i 30 gi√¢y...")
                    time.sleep(30)
                
                if not latest_run or latest_run['status'] != "completed":
                    print("   - ‚ö†Ô∏è  Workflow kh√¥ng ho√†n th√†nh trong th·ªùi gian ch·ªù. D·ª´ng l·∫°i.")
                    break
                
                if latest_run['conclusion'] == "success":
                    self.state = "DONE"
                    print("\n" + "="*50 + "\nüéâüéâüéâ BUILD TH√ÄNH C√îNG! Nhi·ªám v·ª• ho√†n t·∫•t! üéâüéâüéâ\n" + f"   - Link Repo: https://github.com/{self.actions.repo_full_name}\n" + "="*50)
                    return True

                elif latest_run['conclusion'] == "failure":
                    self.debug_attempts += 1
                    self.state = f"DEBUGGING_ATTEMPT_{self.debug_attempts}"
                    print(f"   - üìâ Build th·∫•t b·∫°i. B·∫Øt ƒë·∫ßu quy tr√¨nh g·ª° l·ªói.")
                    
                    error_log = self.actions.get_failed_job_log(latest_run['id'])
                    files_to_read = ["pubspec.yaml", "lib/main.dart"]
                    files_content_map = {path: self.actions.get_file_content(path) for path in files_to_read}
                    
                    debug_prompt = f"M·ªôt build Flutter ƒë√£ th·∫•t b·∫°i. Ph√¢n t√≠ch log v√† code ƒë·ªÉ s·ª≠a l·ªói.\n\n--- LOG L·ªñI ---\n{error_log}\n\n" + "".join([f"--- File `{path}` ---\n{content}\n" for path, (content, sha) in files_content_map.items() if content]) + "\n\n**NHI·ªÜM V·ª§:** Tr·∫£ v·ªÅ m·ªôt JSON duy nh·∫•t v·ªõi c·∫•u tr√∫c: `{{\"analysis\": \"...\", \"file_to_patch\": \"...\", \"corrected_code\": \"...\", \"commit_message\": \"...\"}}`"
                    fix_suggestion_text = call_gemini(debug_prompt, use_pro_model=True)
                    fix_suggestion = extract_json_from_ai(fix_suggestion_text)
                    
                    file_to_patch = fix_suggestion.get("file_to_patch")
                    if file_to_patch and file_to_patch in files_content_map:
                        _, current_sha = files_content_map[file_to_patch]
                        if not current_sha: raise ValueError(f"Kh√¥ng th·ªÉ l·∫•y SHA c·ªßa file {file_to_patch} ƒë·ªÉ v√° l·ªói.")
                        self.actions.apply_code_patch(file_to_patch, fix_suggestion["corrected_code"], fix_suggestion["commit_message"], current_sha)
                        print("   - ‚úÖ ƒê√£ √°p d·ª•ng b·∫£n v√°. V√≤ng l·∫∑p s·∫Ω b·∫Øt ƒë·∫ßu l·∫°i...")
                    else:
                        print("   - üí° AI kh√¥ng th·ªÉ t√¨m ra c√°ch s·ª≠a. D·ª´ng l·∫°i.")
                        break
            
            if self.debug_attempts >= MAX_DEBUG_LOOPS:
                print(f"\nüö® ƒê√£ ƒë·∫°t gi·ªõi h·∫°n {MAX_DEBUG_LOOPS} l·∫ßn s·ª≠a l·ªói. T√°c nh√¢n d·ª´ng l·∫°i.")
            
        except Exception as e:
            print("\n‚ùå L·ªñI NGHI√äM TR·ªåNG TRONG QU√Å TR√åNH TH·ª∞C THI:")
            traceback.print_exc()

# ==============================================================================
# V. ƒêI·ªÇM KH·ªûI ƒê·ªòNG
# ==============================================================================
if __name__ == "__main__":
    try:
        user_prompt = Path("prompt.txt").read_text(encoding="utf-8")
        repo_name = input("üìÅ Nh·∫≠p t√™n cho repo m·ªõi: ")
        if not repo_name: raise ValueError("T√™n repo kh√¥ng ƒë∆∞·ª£c ƒë·ªÉ tr·ªëng.")
        agent = AutonomousAgent(user_prompt, repo_name)
        agent.run()
    except FileNotFoundError:
        print("‚ùå L·ªñI: Kh√¥ng t√¨m th·∫•y file 'prompt.txt'.")
    except Exception as e:
        print(f"\n‚ùå L·ªñI KH√îNG X√ÅC ƒê·ªäNH TR∆Ø·ªöC KHI KH·ªûI ƒê·ªòNG AGENT: {e}")
        traceback.print_exc()
